<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#7c2d12">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎃 Spooky Sliding Puzzle 👻</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <style>
        @keyframes float {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
            }

            25% {
                transform: translateY(-20px) rotate(5deg);
            }

            50% {
                transform: translateY(-40px) rotate(-5deg);
            }

            75% {
                transform: translateY(-20px) rotate(3deg);
            }
        }

        @keyframes glow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 107, 53, 0.5), 0 0 40px rgba(255, 107, 53, 0.3);
            }

            50% {
                box-shadow: 0 0 40px rgba(255, 107, 53, 0.8), 0 0 60px rgba(255, 107, 53, 0.5);
            }
        }

        @keyframes shake {
            0%, 100% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(-3deg);
            }

            75% {
                transform: rotate(3deg);
            }
        }

        @keyframes bloodSlide {
            0% {
                box-shadow: 0 0 0 rgba(139, 0, 0, 0);
            }

            50% {
                box-shadow: 0 0 30px rgba(139, 0, 0, 0.8), 0 0 50px rgba(220, 20, 60, 0.6);
            }

            100% {
                box-shadow: 0 0 0 rgba(139, 0, 0, 0);
            }
        }

        .blood-slide {
            animation: bloodSlide 0.3s ease-out;
        }

        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(to bottom right, #7c2d12, #4c1d95, #000000);
            min-height: 100%;
        }

        #root {
            min-height: 100%;
            width: 100%;
        }

        .puzzle-container {
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            max-height: 95vh;
        }

        .puzzle-board {
            overflow: hidden;
            touch-action: pan-y;
        }

        @media (max-width: 768px) {
            .blood-slide {
                animation: bloodSlide 0.2s ease-out;
            }

            .animate-pulse {
                animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
            }

            .tile-hover-disable:hover {
                transform: none !important;
            }

            .puzzle-container {
                max-height: 92vh;
            }

            .puzzle-board {
                width: 100%;
                max-width: 100vw;
            }
        }

        .gpu-accelerated {
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }

        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .tile-active:active {
            transform: scale(0.95) rotate(2deg);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .game-locked {
            position: relative;
        }

            .game-locked::after {
                content: "";
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.7);
                border-radius: 0.5rem;
                z-index: 10;
            }

        .game-locked-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 11;
            color: white;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
            text-shadow: 0 0 10px rgba(255, 107, 53, 0.8);
            width: 80%;
        }

        .leaderboard-container {
            max-height: 50vh;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .leaderboard-container {
                max-height: 40vh;
            }
        }

        /* 新增样式：图片裁剪预览 */
        .image-preview {
            max-width: 100%;
            max-height: 200px;
            object-fit: cover;
            border: 2px solid #f97316;
            border-radius: 0.5rem;
            margin: 0.5rem 0;
        }

        .crop-controls {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin: 0.5rem 0;
            border: 1px solid #f97316;
        }

        /* 新增样式：九宫格预览 */
        .grid-preview {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 100%;
            height: 150px;
            margin: 0.5rem 0;
            border: 2px solid #f97316;
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .grid-cell {
            background-size: 300% 300%;
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }

            .grid-cell:hover {
                transform: scale(1.05);
                z-index: 1;
                box-shadow: 0 0 10px rgba(255, 107, 53, 0.7);
            }

        /* 新增样式：贡献者信息 */
        .contributor-info {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 0.5rem;
            padding: 0.5rem;
            margin: 0.5rem 0;
            border: 1px solid #8b5cf6;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    let keepAliveTimer;
    function keepPageAlive() {
      if (document.hidden) return;
      keepAliveTimer = setTimeout(keepPageAlive, 30000);
    }
    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        keepPageAlive();
      } else {
        clearTimeout(keepAliveTimer);
      }
    });
    keepPageAlive();

    // ═══════════════════════════════════════════════════════════════════════
    // 🔥 FIREBASE CONFIGURATION
    // ═══════════════════════════════════════════════════════════════════════

    const firebaseConfig = {
      apiKey: "AIzaSyCdyeAVxETu5upcMAIWIKi5ykuqcuhSDXk",
      authDomain: "spooky-puzzle-game-7dcf4.firebaseapp.com",
      projectId: "spooky-puzzle-game-7dcf4",
      storageBucket: "spooky-puzzle-game-7dcf4.firebasestorage.app",
      messagingSenderId: "838626431807",
      appId: "1:838626431807:web:c0c6e5d151e395f3e8b98a"
    };

    // ═══════════════════════════════════════════════════════════════════════
    // 📸 CLOUDINARY CONFIGURATION
    // ═══════════════════════════════════════════════════════════════════════
    const CLOUDINARY_CLOUD_NAME = "ducawrgba";
    const CLOUDINARY_UPLOAD_PRESET = "Pangea";

    const halloweenImages = [
        {
            url: 'https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8M3x8aGFsbG93ZWVufGVufDB8fDB8fHww&auto=format&fit=crop&w=500&q=60',
            contributor: 'Unsplash'
        },
        {
            url: 'https://images.unsplash.com/photo-1572863141204-83031c77e13a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8NHx8aGFsbG93ZWVufGVufDB8fDB8fHww&auto=format&fit=crop&w=500&q=60',
            contributor: 'Unsplash'
        },
        {
            url: 'https://images.unsplash.com/photo-1531123897727-8f129e1688ce?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8NXx8aGFsbG93ZWVufGVufDB8fDB8fHww&auto=format&fit=crop&w=500&q=60',
            contributor: 'Unsplash'
        },
        {
            url: 'https://images.unsplash.com/photo-1572863141204-83031c77e13a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8Mnx8aGFsbG93ZWVufGVufDB8fDB8fHww&auto=format&fit=crop&w=500&q=60',
            contributor: 'Unsplash'
        },
        {
            url: 'https://images.unsplash.com/photo-1508361001413-7a9dca21d08a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTB8fGhhbGxvd2VlbnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&w=500&q=60',
            contributor: 'Unsplash'
        },
        {
            url: 'https://images.unsplash.com/photo-1531123897727-8f129e1688ce?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTJ8fGhhbGxvd2VlbnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&w=500&q=60',
            contributor: 'Unsplash'
        },
        {
            url: 'https://images.unsplash.com/photo-1508361001413-7a9dca21d08a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTR8fGhhbGxvd2VlbnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&w=500&q=60',
            contributor: 'Unsplash'
        },
        {
            url: 'https://images.unsplash.com/photo-1572863141204-83031c77e13a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MTZ8fGhhbGxvd2VlbnxlbnwwfHwwfHx8MA%3D%3D&auto=format&fit=crop&w=500&q=60',
            contributor: 'Unsplash'
        }
    ];

    function saveGameState(state) {
        try {
            localStorage.setItem('spooky_puzzle_state', JSON.stringify(state));
        } catch (e) {
            console.log('Could not save game state');
        }
    }

    function loadGameState() {
        try {
            const saved = localStorage.getItem('spooky_puzzle_state');
            return saved ? JSON.parse(saved) : null;
        } catch (e) {
            return null;
        }
    }

    let db = null;
    let firebaseInitialized = false;

    try {
      if (firebaseConfig.apiKey !== "YOUR_API_KEY_HERE") {
        if (!firebase.apps.length) {
          firebase.initializeApp(firebaseConfig);
        }
        db = firebase.firestore();
        firebaseInitialized = true;
        console.log("✅ Firebase initialized successfully! Global leaderboard is active.");
      } else {
        console.log("⚠️ Firebase not configured. Using local storage only.");
      }
    } catch (error) {
      console.error("❌ Firebase initialization error:", error);
      console.log("📝 Using local storage fallback.");
    }

    function SlidingPuzzle() {
      const [isMobile, setIsMobile] = useState(false);
      const saveGameStateDebounced = useRef(null);
      const [tiles, setTiles] = useState([0, 1, 2, 3, 4, 5, 6, 7, 8]);
      const [moves, setMoves] = useState(0);
      const [image, setImage] = useState(null);
      const [imageContributor, setImageContributor] = useState('');
      const [isWon, setIsWon] = useState(false);
      const [floatingIcons, setFloatingIcons] = useState([]);
      const [playerName, setPlayerName] = useState('');
      const [showNameInput, setShowNameInput] = useState(false);
      const [leaderboard, setLeaderboard] = useState([]);
      const [showLeaderboard, setShowLeaderboard] = useState(false);
      const [startTime, setStartTime] = useState(null);
      const [completionTime, setCompletionTime] = useState(0);
      const [animatingTile, setAnimatingTile] = useState(null);
      const [gameStarted, setGameStarted] = useState(false);
      const [uploadedImages, setUploadedImages] = useState([]);
      const [isUploading, setIsUploading] = useState(false);
      const [showCropControls, setShowCropControls] = useState(false);
      const [cropPosition, setCropPosition] = useState({ x: 50, y: 50 });
      const [cropZoom, setCropZoom] = useState(1);
      const [tempImage, setTempImage] = useState(null);
      const [canUpload, setCanUpload] = useState(false);
      const [gamesCompleted, setGamesCompleted] = useState(0);
      const fileInputRef = useRef(null);
      const puzzleBoardRef = useRef(null);

      useEffect(() => {
        const checkScreenSize = () => {
          const mobile = window.innerWidth < 768;
          setIsMobile(mobile);

          if (mobile && puzzleBoardRef.current) {
            const container = puzzleBoardRef.current.parentElement;
            const containerWidth = container.clientWidth;
            const boardSize = containerWidth - 32;
            puzzleBoardRef.current.style.width = `${boardSize}px`;
            puzzleBoardRef.current.style.height = `${boardSize}px`;
          }
        };

        checkScreenSize();
        window.addEventListener('resize', checkScreenSize);

        return () => {
          window.removeEventListener('resize', checkScreenSize);
        };
      }, []);

      useEffect(() => {
        if (saveGameStateDebounced.current) {
          clearTimeout(saveGameStateDebounced.current);
        }

        saveGameStateDebounced.current = setTimeout(() => {
          const gameState = {
            tiles,
            moves,
            image,
            imageContributor,
            startTime,
            completionTime,
            gameStarted,
            gamesCompleted,
            canUpload
          };
          saveGameState(gameState);
          saveGameStateDebounced.current = null;
        }, 500);

        return () => {
          if (saveGameStateDebounced.current) {
            clearTimeout(saveGameStateDebounced.current);
          }
        };
      }, [tiles, moves, image, imageContributor, startTime, completionTime, gameStarted, gamesCompleted, canUpload]);

      useEffect(() => {
        const savedState = loadGameState();
        if (savedState) {
          setTiles(savedState.tiles || [0,1,2,3,4,5,6,7,8]);
          setMoves(savedState.moves || 0);
          setImage(savedState.image || null);
          setImageContributor(savedState.imageContributor || '');
          setStartTime(savedState.startTime || null);
          setCompletionTime(savedState.completionTime || 0);
          setGameStarted(savedState.gameStarted || false);
          setGamesCompleted(savedState.gamesCompleted || 0);
          setCanUpload(savedState.canUpload || false);
        } else {
          setRandomHalloweenImage();
        }

        loadLeaderboard();
        loadUploadedImages();
      }, []);

      useEffect(() => {
        const isMobile = window.innerWidth < 768;
        const totalIcons = isMobile ? 8 : 15;

        const icons = ['👻', '🎃', '🦇', '🕷️', '💀', '🕸️', '🐈‍⬛'];
        const positions = [];

        for (let i = 0; i < totalIcons; i++) {
          const isLeft = i < totalIcons / 2;
          positions.push({
            id: `${isLeft ? 'left' : 'right'}-${i}`,
            icon: icons[Math.floor(Math.random() * icons.length)],
            left: isLeft ?
              (2 + Math.random() * 15) :
              (70 + Math.random() * (30 - 3)),
            top: 5 + Math.random() * 90,
            size: Math.random() * 1.0 + 0.6,
            duration: Math.random() * 15 + 10,
            delay: Math.random() * 5
          });
        }

        setFloatingIcons(positions);
      }, []);

      const setRandomHalloweenImage = () => {
        if (uploadedImages.length > 0) {
          const randomIndex = Math.floor(Math.random() * uploadedImages.length);
          setImage(uploadedImages[randomIndex].url);
          setImageContributor(uploadedImages[randomIndex].contributor || 'Anonymous');
        } else {
          const randomIndex = Math.floor(Math.random() * halloweenImages.length);
          setImage(halloweenImages[randomIndex].url);
          setImageContributor(halloweenImages[randomIndex].contributor);
        }
      };

      const loadUploadedImages = async () => {
        if (db && firebaseInitialized) {
          try {
            const snapshot = await db.collection('uploaded_images')
              .orderBy('timestamp', 'desc')
              .limit(50)
              .get();

            const images = [];
            snapshot.forEach(doc => {
              const data = doc.data();
              if (data.imageUrl) {
                images.push({
                  url: data.imageUrl,
                  contributor: data.contributor || 'Anonymous',
                  timestamp: data.timestamp
                });
              }
            });

            console.log('Loaded uploaded images:', images.length);
            setUploadedImages(images);

            if (!image && images.length > 0) {
              const randomIndex = Math.floor(Math.random() * images.length);
              setImage(images[randomIndex].url);
              setImageContributor(images[randomIndex].contributor);
            }
          } catch (error) {
            console.error('Error loading uploaded images:', error);
          }
        }
      };

      const uploadToCloudinary = async (file) => {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);

        try {
          const response = await fetch(
            `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`,
            {
              method: 'POST',
              body: formData
            }
          );

          if (!response.ok) {
            throw new Error('Upload failed');
          }

          const data = await response.json();
          return data.secure_url;
        } catch (error) {
          console.error('Cloudinary upload error:', error);
          throw error;
        }
      };

      const saveImageToFirebase = async (imageUrl, contributor) => {
        if (db && firebaseInitialized) {
          try {
            await db.collection('uploaded_images').add({
              imageUrl: imageUrl,
              contributor: contributor,
              timestamp: Date.now()
            });
            console.log('Image URL saved to Firebase');
          } catch (error) {
            console.error('Error saving image URL to Firebase:', error);
          }
        }
      };

      const filterLeaderboard = (scores) => {
        const userBestScores = {};

        scores.forEach(score => {
          const name = score.name;
          if (!userBestScores[name] ||
              score.moves < userBestScores[name].moves ||
              (score.moves === userBestScores[name].moves && score.time < userBestScores[name].time)) {
            userBestScores[name] = score;
          }
        });

        return Object.values(userBestScores)
          .sort((a, b) => {
            if (a.moves !== b.moves) return a.moves - b.moves;
            return a.time - b.time;
          })
          .slice(0, 50);
      };

      const loadLeaderboard = async () => {
        console.log('Loading leaderboard...');

        if (db && firebaseInitialized) {
          try {
            const snapshot = await db.collection('scores')
              .orderBy('moves')
              .orderBy('time')
              .limit(100)
              .get();

            const scores = [];
            snapshot.forEach(doc => {
              const data = doc.data();
              scores.push({
                ...data,
                id: doc.id,
                timestamp: data.timestamp || Date.now()
              });
            });

            console.log('Firebase scores loaded:', scores.length);
            const filteredScores = filterLeaderboard(scores);
            setLeaderboard(filteredScores);
            return;
          } catch (error) {
            console.error('Error loading Firebase leaderboard:', error);
            console.log('Falling back to local storage...');
          }
        }

        loadLocalLeaderboard();
      };

      const loadLocalLeaderboard = () => {
        try {
          const stored = localStorage.getItem('spooky_leaderboard');
          if (stored) {
            const scores = JSON.parse(stored);
            const filteredScores = filterLeaderboard(scores);
            console.log('Local scores loaded:', filteredScores.length);
            setLeaderboard(filteredScores);
          } else {
            setLeaderboard([]);
          }
        } catch (error) {
          console.error('Error loading local leaderboard:', error);
          setLeaderboard([]);
        }
      };

      const checkWin = (currentTiles) => {
        return currentTiles.every((tile, index) => tile === index);
      };

      const getEmptyIndex = (currentTiles) => {
        return currentTiles.indexOf(8);
      };

      const canMove = (tileIndex, emptyIndex) => {
        const tileRow = Math.floor(tileIndex / 3);
        const tileCol = tileIndex % 3;
        const emptyRow = Math.floor(emptyIndex / 3);
        const emptyCol = emptyIndex % 3;

        return (
          (Math.abs(tileRow - emptyRow) === 1 && tileCol === emptyCol) ||
          (Math.abs(tileCol - emptyCol) === 1 && tileRow === emptyRow)
        );
      };

      const handleTileClick = (index) => {
        if (!gameStarted || isWon) return;

        const emptyIndex = getEmptyIndex(tiles);

        if (canMove(index, emptyIndex)) {
          const newTiles = [...tiles];
          [newTiles[index], newTiles[emptyIndex]] = [newTiles[emptyIndex], newTiles[index]];
          setTiles(newTiles);
          setMoves(moves + 1);

          setAnimatingTile(emptyIndex);
          setTimeout(() => setAnimatingTile(null), 300);

          if (checkWin(newTiles)) {
            const endTime = Date.now();
            const timeTaken = Math.floor((endTime - startTime) / 1000);
            setCompletionTime(timeTaken);
            setIsWon(true);
            setShowNameInput(true);
            setGameStarted(false);
            // 解锁上传功能
            setCanUpload(true);
            setGamesCompleted(prev => prev + 1);
          }
        }
      };

      const shuffleTiles = () => {
        let shuffled = [...tiles];

        for (let i = 0; i < 100; i++) {
          const emptyIndex = shuffled.indexOf(8);
          const validMoves = [];

          const row = Math.floor(emptyIndex / 3);
          const col = emptyIndex % 3;

          if (row > 0) validMoves.push(emptyIndex - 3);
          if (row < 2) validMoves.push(emptyIndex + 3);
          if (col > 0) validMoves.push(emptyIndex - 1);
          if (col < 2) validMoves.push(emptyIndex + 1);

          const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
          [shuffled[emptyIndex], shuffled[randomMove]] = [shuffled[randomMove], shuffled[emptyIndex]];
        }

        setTiles(shuffled);
        setMoves(0);
        setIsWon(false);
        setStartTime(Date.now());
        setShowNameInput(false);
        setGameStarted(true);

        if (!image) {
          setRandomHalloweenImage();
        }
      };

      const resetPuzzle = () => {
        setTiles([0, 1, 2, 3, 4, 5, 6, 7, 8]);
        setMoves(0);
        setIsWon(false);
        setStartTime(null);
        setShowNameInput(false);
        setGameStarted(false);

        setRandomHalloweenImage();
      };

      const handleCropConfirm = async () => {
        if (!tempImage) return;

        setIsUploading(true);
        try {
          // 将裁剪后的图片转换为Blob进行上传
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();

          img.onload = async () => {
            // 设置画布大小为正方形，适合拼图
            const size = Math.min(img.width, img.height) * cropZoom;
            canvas.width = size;
            canvas.height = size;

            // 计算裁剪区域
            const sourceX = (img.width - size) * (cropPosition.x / 100);
            const sourceY = (img.height - size) * (cropPosition.y / 100);

            ctx.drawImage(
              img,
              sourceX, sourceY, size, size,
              0, 0, size, size
            );

            // 将画布内容转换为Blob
            canvas.toBlob(async (blob) => {
              try {
                const imageUrl = await uploadToCloudinary(blob);
                await saveImageToFirebase(imageUrl, playerName || 'Anonymous');
                await loadUploadedImages();
                setImage(imageUrl);
                setImageContributor(playerName || 'Anonymous');
                resetPuzzle();
                setShowCropControls(false);
                setTempImage(null);
                // 使用一次上传机会
                setCanUpload(false);

                alert('🎉 Image uploaded successfully! Other players can now use it in their puzzles! 📸');
              } catch (error) {
                console.error('Upload error:', error);
                alert('❌ Failed to upload image. Please try again.');
              } finally {
                setIsUploading(false);
              }
            }, 'image/jpeg', 0.9);
          };

          img.src = tempImage;
        } catch (error) {
          console.error('Crop error:', error);
          alert('❌ Failed to process image. Please try again.');
          setIsUploading(false);
        }
      };

      const handleImageUpload = async (e) => {
        const file = e.target.files[0];
        if (file) {
          if (file.size > 5 * 1024 * 1024) {
            alert('⚠️ Image too large! Please upload an image smaller than 5MB.');
            return;
          }

          // 如果是本地模式，直接使用图片
          if (CLOUDINARY_CLOUD_NAME === "YOUR_CLOUD_NAME" || CLOUDINARY_UPLOAD_PRESET === "YOUR_UPLOAD_PRESET") {
            const reader = new FileReader();
            reader.onload = (event) => {
              setImage(event.target.result);
              setImageContributor(playerName || 'You');
              resetPuzzle();
              alert('⚠️ Image loaded locally. Configure Cloudinary to share images with other players!');
            };
            reader.readAsDataURL(file);
            return;
          }

          // 显示裁剪界面
          const reader = new FileReader();
          reader.onload = (event) => {
            setTempImage(event.target.result);
            setShowCropControls(true);
            setCropPosition({ x: 50, y: 50 });
            setCropZoom(1);
          };
          reader.readAsDataURL(file);
        }
      };

      const isScoreBetter = (existingScore, newScore) => {
        if (newScore.moves < existingScore.moves) return true;
        if (newScore.moves === existingScore.moves && newScore.time < existingScore.time) return true;
        return false;
      };

      const saveScore = async () => {
        if (!playerName.trim()) {
            alert('Please enter your name! 👻');
            return;
        }

        const scoreData = {
            name: playerName.trim(),
            moves: moves,
            time: completionTime,
            timestamp: Date.now()
        };

        console.log('Saving score:', scoreData);

        if (db && firebaseInitialized) {
            try {
                const existingScoresQuery = await db.collection('scores')
                    .where('name', '==', playerName.trim())
                    .get();

                let shouldSave = true;

                if (!existingScoresQuery.empty) {
                    let bestExistingScore = null;
                    existingScoresQuery.forEach(doc => {
                        const data = doc.data();
                        if (!bestExistingScore || isScoreBetter(bestExistingScore, data)) {
                            bestExistingScore = data;
                        }
                    });

                    if (bestExistingScore && !isScoreBetter(bestExistingScore, scoreData)) {
                        shouldSave = false;
                        alert(`⚠️ You already have a better score: ${bestExistingScore.moves} moves in ${formatTime(bestExistingScore.time)}. This score was not saved.`);
                    } else {
                        const batch = db.batch();
                        existingScoresQuery.forEach(doc => {
                            batch.delete(doc.ref);
                        });
                        await batch.commit();
                    }
                }

                if (shouldSave) {
                    await db.collection('scores').add(scoreData);
                    setShowNameInput(false);
                    setPlayerName('');

                    await loadLeaderboard();
                    setShowLeaderboard(true);

                    alert('🎉 Score saved to GLOBAL leaderboard! Everyone can see your achievement! 🏆');
                }
                return;
            } catch (error) {
                console.error('Failed to save to Firebase:', error);
                alert('⚠️ Could not save to global leaderboard. Saving locally instead...');
            }
        }

        try {
            const stored = localStorage.getItem('spooky_leaderboard');
            let scores = stored ? JSON.parse(stored) : [];

            const existingScores = scores.filter(score => score.name === playerName.trim());
            let shouldSave = true;

            if (existingScores.length > 0) {
                let bestExistingScore = existingScores[0];
                existingScores.forEach(score => {
                    if (isScoreBetter(score, bestExistingScore)) {
                        bestExistingScore = score;
                    }
                });

                if (!isScoreBetter(bestExistingScore, scoreData)) {
                    shouldSave = false;
                    alert(`⚠️ You already have a better score: ${bestExistingScore.moves} moves in ${formatTime(bestExistingScore.time)}. This score was not saved.`);
                } else {
                    scores = scores.filter(score => score.name !== playerName.trim());
                }
            }

            if (shouldSave) {
                scores.push(scoreData);

                scores.sort((a, b) => {
                    if (a.moves !== b.moves) return a.moves - b.moves;
                    return a.time - b.time;
                });

                const topScores = scores.slice(0, 50);

                localStorage.setItem('spooky_leaderboard', JSON.stringify(topScores));
                setShowNameInput(false);
                setPlayerName('');

                setLeaderboard(topScores);
                setShowLeaderboard(true);

                alert('🎉 Score saved locally! (Only you can see this score)');
            }
        } catch (error) {
            console.error('Failed to save score:', error);
            alert('❌ Failed to save score. Please try again.');
        }
      };

      const formatTime = (seconds) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      };

      const getTileStyle = (tileNumber) => {
        if (tileNumber === 8) return {};

        const row = Math.floor(tileNumber / 3);
        const col = tileNumber % 3;

        return {
          backgroundImage: image ? `url(${image})` : 'linear-gradient(135deg, #ff6b35 0%, #8b0000 100%)',
          backgroundSize: '300% 300%', // 确保图片正确分割为3x3网格
          backgroundPosition: `${col * 50}% ${row * 50}%`,
        };
      };

      const getCropPreviewStyle = () => {
        if (!tempImage) return {};

        return {
          backgroundImage: `url(${tempImage})`,
          backgroundSize: `${100 * cropZoom}%`,
          backgroundPosition: `${cropPosition.x}% ${cropPosition.y}%`,
          backgroundRepeat: 'no-repeat'
        };
      };

      // 获取九宫格预览中每个格子的样式
      const getGridCellStyle = (row, col) => {
        if (!tempImage) return {};

        return {
          backgroundImage: `url(${tempImage})`,
          backgroundSize: `${300 * cropZoom}%`, // 3倍放大因为要显示3x3网格
          backgroundPosition: `${(col * 100 / 2) + (50 - cropPosition.x) * cropZoom}% ${(row * 100 / 2) + (50 - cropPosition.y) * cropZoom}%`,
        };
      };

      return (
        <div className="min-h-full flex flex-col items-center p-0 game-container">
          {floatingIcons.map((item) => (
            <div
              key={item.id}
              className="fixed animate-pulse opacity-20 pointer-events-none"
              style={{
                left: `${item.left}%`,
                top: `${item.top}%`,
                fontSize: `${item.size}rem`,
                animation: `float ${item.duration}s ease-in-out infinite`,
                animationDelay: `${item.delay}s`,
              }}
            >
              {item.icon}
            </div>
          ))}

          <div className="puzzle-container bg-gradient-to-br from-gray-900 to-black rounded-xl shadow-2xl p-2 md:p-3 max-w-md w-full border-2 border-orange-600 relative z-10 my-0">
            <div className="absolute top-0 left-0 text-4xl opacity-40 animate-pulse">🕸️</div>
            <div className="absolute top-0 right-0 text-4xl opacity-40 transform scale-x-[-1] animate-pulse">🕸️</div>
            <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 text-3xl" style={{animation: 'shake 2s ease-in-out infinite'}}>🕷️</div>

            <div className="absolute -top-1 -left-1 text-2xl animate-bounce">🎃</div>
            <div className="absolute -top-1 -right-1 text-2xl animate-bounce" style={{animationDelay: '0.5s'}}>👻</div>
            <div className="absolute -bottom-1 -left-1 text-2xl animate-bounce" style={{animationDelay: '1s'}}>💀</div>
            <div className="absolute -bottom-1 -right-1 text-2xl animate-bounce" style={{animationDelay: '1.5s'}}>🦇</div>

            <h1 className="text-2xl font-bold text-center mb-0 text-orange-500 drop-shadow-lg animate-pulse" style={{fontFamily: 'Georgia, serif', textShadow: '0 0 20px rgba(255, 107, 53, 0.8)'}}>
              🎃 Spooky Puzzle 🎃
            </h1>
            <p className="text-center text-orange-300 mb-1 text-xs italic animate-pulse">
              Dare to solve it... if you can! 👻
            </p>
            {!firebaseInitialized && (
              <p className="text-center text-yellow-400 text-xs mb-1 bg-black bg-opacity-40 rounded px-2 py-1">
                ℹ️ Local mode - Configure Firebase for global leaderboard
              </p>
            )}
            {firebaseInitialized && (
              <p className="text-center text-green-400 text-xs mb-1 bg-black bg-opacity-40 rounded px-2 py-1">
                🌍 Global leaderboard active!
              </p>
            )}

            <div className="mb-2 flex flex-col gap-1">
              <input
                ref={fileInputRef}
                type="file"
                accept="image/*"
                onChange={handleImageUpload}
                className="hidden"
                disabled={isUploading || !canUpload}
              />

              {canUpload ? (
                <button
                  onClick={() => fileInputRef.current.click()}
                  disabled={isUploading}
                  className={`w-full ${isUploading ? 'bg-gradient-to-r from-gray-600 to-gray-800 cursor-wait' : 'bg-gradient-to-r from-purple-600 to-purple-800 hover:from-purple-700 hover:to-purple-900'} text-white font-semibold py-1 px-3 rounded-lg transition-all flex items-center justify-center gap-1 border-2 border-purple-400 shadow-lg hover:shadow-purple-500 ${!isUploading && 'hover:scale-105 active:scale-95'} text-xs`}
                >
                  {isUploading ? (
                    <>⏳ Uploading... 📸</>
                  ) : (
                    <>📤 Upload Your Photo 📸</>
                  )}
                </button>
              ) : (
                <div className="bg-gray-800 bg-opacity-60 border border-gray-600 rounded-lg p-2 text-center">
                  <p className="text-gray-300 text-xs">
                    🔒 Complete a puzzle to unlock photo upload!
                    {gamesCompleted > 0 && (
                      <span className="text-purple-300"> ({gamesCompleted} game{gamesCompleted !== 1 ? 's' : ''} completed)</span>
                    )}
                  </p>
                </div>
              )}

              {showCropControls && (
                <div className="crop-controls">
                  <p className="text-purple-200 text-xs text-center mb-2">
                    ✂️ Adjust your photo for the puzzle:
                  </p>

                  {/* 裁剪预览 */}
                  <div
                    className="image-preview mx-auto"
                    style={{
                      ...getCropPreviewStyle(),
                      width: '100%',
                      height: '150px',
                      backgroundSize: `${100 * cropZoom}%`,
                      backgroundPosition: `${cropPosition.x}% ${cropPosition.y}%`
                    }}
                  />

                  {/* 九宫格预览 */}
                  <div className="mb-2">
                    <p className="text-orange-300 text-xs text-center mb-1">Puzzle Preview:</p>
                    <div className="grid-preview">
                      {[...Array(9)].map((_, index) => {
                        const row = Math.floor(index / 3);
                        const col = index % 3;
                        return (
                          <div
                            key={index}
                            className="grid-cell"
                            style={getGridCellStyle(row, col)}
                          />
                        );
                      })}
                    </div>
                  </div>

                  {/* 裁剪控制 */}
                  <div className="space-y-2">
                    <div>
                      <label className="text-orange-300 text-xs">Position X: {cropPosition.x}%</label>
                      <input
                        type="range"
                        min="0"
                        max="100"
                        value={cropPosition.x}
                        onChange={(e) => setCropPosition(prev => ({ ...prev, x: parseInt(e.target.value) }))}
                        className="w-full"
                      />
                    </div>

                    <div>
                      <label className="text-orange-300 text-xs">Position Y: {cropPosition.y}%</label>
                      <input
                        type="range"
                        min="0"
                        max="100"
                        value={cropPosition.y}
                        onChange={(e) => setCropPosition(prev => ({ ...prev, y: parseInt(e.target.value) }))}
                        className="w-full"
                      />
                    </div>

                    <div>
                      <label className="text-orange-300 text-xs">Zoom: {cropZoom.toFixed(1)}x</label>
                      <input
                        type="range"
                        min="0.5"
                        max="2"
                        step="0.1"
                        value={cropZoom}
                        onChange={(e) => setCropZoom(parseFloat(e.target.value))}
                        className="w-full"
                      />
                    </div>
                  </div>

                  <div className="flex gap-2 mt-2">
                    <button
                      onClick={() => {
                        setShowCropControls(false);
                        setTempImage(null);
                      }}
                      className="flex-1 bg-gradient-to-r from-gray-600 to-gray-800 text-white font-semibold py-1 px-3 rounded-lg transition-all border border-gray-400 hover:scale-105 active:scale-95 text-xs"
                    >
                      Cancel
                    </button>
                    <button
                      onClick={handleCropConfirm}
                      disabled={isUploading}
                      className="flex-1 bg-gradient-to-r from-green-600 to-green-800 text-white font-semibold py-1 px-3 rounded-lg transition-all border border-green-400 hover:scale-105 active:scale-95 text-xs"
                    >
                      {isUploading ? 'Uploading...' : 'Confirm Crop & Upload'}
                    </button>
                  </div>
                </div>
              )}

              {/* 贡献者信息 */}
              {imageContributor && (
                <div className="contributor-info">
                  <p className="text-purple-200 text-xs">
                    📸 Photo by: <span className="text-purple-300 font-semibold">{imageContributor}</span>
                  </p>
                </div>
              )}

              <div className="bg-purple-900 bg-opacity-60 border border-purple-400 rounded-lg p-1 text-center">
                <p className="text-purple-200 text-xs">
                  💡 <span className="font-semibold">Share the fun!</span> Complete a puzzle to upload your photo!
                  {uploadedImages.length > 0 && (
                    <span className="text-purple-300"> ({uploadedImages.length} photos shared so far!)</span>
                  )}
                </p>
              </div>

              <div className="flex gap-1">
                <button
                  onClick={shuffleTiles}
                  className="flex-1 bg-gradient-to-r from-orange-600 to-orange-800 hover:from-orange-700 hover:to-orange-900 text-white font-semibold py-1 px-3 rounded-lg transition-all flex items-center justify-center gap-1 border-2 border-orange-400 shadow-lg hover:shadow-orange-500 hover:scale-105 active:scale-95 text-xs"
                >
                  🔀 Haunt 🎃
                </button>
                <button
                  onClick={resetPuzzle}
                  className="flex-1 bg-gradient-to-r from-gray-600 to-gray-800 hover:from-gray-700 hover:to-gray-900 text-white font-semibold py-1 px-3 rounded-lg transition-all flex items-center justify-center gap-1 border-2 border-gray-400 shadow-lg hover:shadow-gray-500 hover:scale-105 active:scale-95 text-xs"
                >
                  ↺ Reset 🦇
                </button>
              </div>

              <button
                onClick={() => setShowLeaderboard(!showLeaderboard)}
                className="w-full bg-gradient-to-r from-yellow-600 to-yellow-800 hover:from-yellow-700 hover:to-yellow-900 text-white font-semibold py-1 px-3 rounded-lg transition-all flex items-center justify-center gap-1 border-2 border-yellow-400 shadow-lg hover:shadow-yellow-500 hover:scale-105 active:scale-95 text-xs"
              >
                🏆 {showLeaderboard ? 'Hide' : 'Show'} Leaderboard 🏆
              </button>
            </div>

            {showLeaderboard && (
              <div className="mb-1 bg-black bg-opacity-80 rounded-lg p-1 border-2 border-yellow-500 leaderboard-container">
                <h3 className="text-md font-bold text-yellow-400 text-center mb-1 flex items-center justify-center gap-1">
                  🏆 Hall of Fame 🏆
                </h3>
                {leaderboard.length === 0 ? (
                  <p className="text-gray-400 text-center text-xs">No scores yet. Be the first! 👻</p>
                ) : (
                  <div className="space-y-1">
                    {leaderboard.map((score, index) => (
                      <div
                        key={score.id || score.timestamp || index}
                        className={`flex items-center justify-between p-1 rounded text-xs ${
                          index === 0
                            ? 'bg-yellow-900 border border-yellow-400'
                            : index === 1
                            ? 'bg-gray-700 border border-gray-400'
                            : index === 2
                            ? 'bg-orange-900 border border-orange-400'
                            : index < 10
                            ? 'bg-purple-900 border border-purple-400'
                            : 'bg-gray-800 border border-gray-600'
                        }`}
                      >
                        <div className="flex items-center gap-1">
                          <span className="font-bold text-white">
                            {index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `#${index + 1}`}
                          </span>
                          <span className="text-white font-semibold">{score.name}</span>
                        </div>
                        <div className="flex items-center gap-1">
                          <span className="text-orange-300">{score.moves} moves</span>
                          <span className="text-blue-300">⏱️ {formatTime(score.time)}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}

            <div className="mb-1 text-center bg-black bg-opacity-50 rounded-lg p-1 border border-orange-500 relative overflow-hidden">
              <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-orange-500 to-transparent animate-pulse"></div>
              <span className="text-sm font-bold text-orange-400 flex items-center justify-center gap-1">
                <span className="animate-pulse">👁️</span>
                Moves: <span className="text-orange-300 text-md">{moves}</span>
                <span className="animate-pulse">👁️</span>
              </span>
              <div className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-orange-500 to-transparent animate-pulse"></div>
            </div>

            {isWon && showNameInput && (
              <div className="mb-1 bg-gradient-to-r from-green-900 to-green-800 border-2 border-green-500 rounded-lg p-1 text-center shadow-xl relative overflow-hidden">
                <p className="text-green-300 font-bold text-md">🎉 BOO-tiful! 🎉</p>
                <p className="text-green-200 text-xs mt-0">You escaped in {moves} moves!</p>
                <p className="text-blue-200 text-xs mt-0 flex items-center justify-center gap-1">
                  ⏱️ Time: {formatTime(completionTime)}
                </p>
                <p className="text-yellow-300 text-lg mt-0 mb-1">🏆👻🦇🎃💀</p>

                <div className="mt-0">
                  <input
                    type="text"
                    placeholder="Enter your name..."
                    value={playerName}
                    onChange={(e) => setPlayerName(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && saveScore()}
                    className="w-full px-2 py-1 rounded-lg bg-black bg-opacity-50 text-white border border-green-400 placeholder-gray-400 focus:outline-none focus:border-green-300 mb-1 text-xs"
                    maxLength={20}
                    autoFocus
                  />
                  <button
                    onClick={saveScore}
                    className="w-full bg-gradient-to-r from-green-600 to-green-800 hover:from-green-700 hover:to-green-900 text-white font-bold py-1 px-3 rounded-lg transition-all border border-green-400 hover:scale-105 active:scale-95 text-xs"
                  >
                    Save Score to Hall of Fame! 🏆
                  </button>
                </div>
              </div>
            )}

            {isWon && !showNameInput && (
              <div className="mb-1 bg-gradient-to-r from-green-900 to-green-800 border-2 border-green-500 rounded-lg p-1 text-center shadow-xl relative overflow-hidden">
                <p className="text-green-300 font-bold text-md">Score Saved! 🎉</p>
                <p className="text-yellow-300 text-lg mt-0">🏆👻🦇🎃💀</p>
              </div>
            )}

            <div
              ref={puzzleBoardRef}
              className={`puzzle-board grid grid-cols-3 gap-1 bg-black bg-opacity-60 p-1 rounded-lg border-2 border-orange-700 shadow-2xl relative mx-auto ${!gameStarted && !isWon ? 'game-locked' : ''}`}
            >
              {!gameStarted && !isWon && (
                <div className="game-locked-text">
                  Click "Haunt" to start the game! 👻
                  {imageContributor && (
                    <div className="mt-2 text-sm text-purple-300">
                      📸 Photo by: {imageContributor}
                    </div>
                  )}
                </div>
              )}

              <div className="absolute -top-0 -left-0 text-lg animate-spin" style={{animationDuration: '10s'}}>🕸️</div>
              <div className="absolute -top-0 -right-0 text-lg animate-spin" style={{animationDuration: '8s', animationDirection: 'reverse'}}>🕸️</div>

              {tiles.map((tile, index) => (
                <div
                  key={index}
                  onClick={() => handleTileClick(index)}
                  onTouchStart={(e) => {
                    handleTileClick(index);
                  }}
                  className={`puzzle-tile aspect-square rounded-lg flex items-center justify-center text-md font-bold transition-all gpu-accelerated no-select tile-active ${
                    tile === 8
                      ? 'bg-gray-900 cursor-default border border-orange-800'
                      : 'bg-white cursor-pointer hover:scale-110 hover:rotate-3 max-md:tile-hover-disable shadow-md hover:shadow-2xl border border-orange-600 hover:border-orange-400'
                  } ${animatingTile === index ? 'blood-slide' : ''}`}
                  style={getTileStyle(tile)}
                >
                  {/* Numbers removed - pure image puzzle */}
                </div>
              ))}

              <div className="absolute -bottom-0 -left-0 text-md animate-bounce">🦇</div>
              <div className="absolute -bottom-0 -right-0 text-md animate-bounce" style={{animationDelay: '0.5s'}}>🐈‍⬛</div>
            </div>

            <div className="mt-1 text-center text-xs text-orange-200 italic flex items-center justify-center gap-1 animate-pulse">
              <span className="text-sm">🕷️</span>
              Click tiles near the void to move them
              <span className="text-sm">🕷️</span>
            </div>

            <div className="mt-0 flex justify-center gap-1 text-lg">
              <span className="animate-bounce">🍬</span>
              <span className="animate-bounce" style={{animationDelay: '0.2s'}}>🍭</span>
              <span className="animate-bounce" style={{animationDelay: '0.4s'}}>🎃</span>
              <span className="animate-bounce" style={{animationDelay: '0.6s'}}>👻</span>
              <span className="animate-bounce" style={{animationDelay: '0.8s'}}>🦇</span>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.render(<SlidingPuzzle />, document.getElementById('root'));
    </script>
</body>
</html>